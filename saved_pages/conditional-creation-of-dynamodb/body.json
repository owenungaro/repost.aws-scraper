{
  "body": "I implemented the solution as below. The stack is created successfully, but the DynamoDB table is not created. It seems that the method dynamodb.TableV2.fromTableName does not return undefined if the table does not exist in AWS.\nCould you please suggest a solution to conditionally create the DynamoDB table only if it does not already exist, and otherwise reference the existing table?\nimport * as dynamodb from 'aws-cdk-lib/aws-dynamodb';\nimport * as cdk from 'aws-cdk-lib';\n\n// ... in your stack definition\n\nconst tableName = 'YourTableName';\n\n// Try to reference an existing table\nconst existingTable = dynamodb.TableV2.fromTableName(this, 'ExistingTable', tableName);\n\nlet table: dynamodb.TableV2;\n\nif (existingTable === undefined) {\n  // Table doesn't exist, create a new one\n  table = new dynamodb.TableV2(this, 'NewTable', {\n    tableName: tableName,\n    partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n    removalPolicy: cdk.RemovalPolicy.RETAIN,\n    // ... other table properties\n  });\n} else {\n  // Table exists, use the reference\n  table = existingTable;\n}\n\n// Now you can use 'table' in the rest of your stack\n\nhey there!\nwhat i'd do is remove the logic that tries to conditionally create the table, and instead just define the table using new dynamodb.TableV2.\nif the table doesn't exist, CDK will create it when you deploy.\nif the table already exists but was created outside CDK, the deployment will fail unless CDK already manages it.\nconst table = new dynamodb.TableV2(this, tableName, {\n  tableName: 'YourTableName',\n  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },\n  removalPolicy: cdk.RemovalPolicy.RETAIN,\n});\njust make sure that the CDK created and owns the table and that it's not created manually or in any other way so you don't get the fail.\n\nThe approach you've taken is on the right track, but there's a slight misunderstanding about how the\nfromTableName\nmethod works in CDK. This method always returns a reference to a table, regardless of whether the table actually exists in AWS or not. It's designed to create a reference without verifying the table's existence.\nTo conditionally create a DynamoDB table only if it doesn't exist, you'll need to use a different approach. Here's a solution that should work:\nUse a custom resource in your CDK stack to check if the table exists.\nBased on the result of this check, either create a new table or reference the existing one.\nHere's how you can implement this:\nimport\n*\nas\ndynamodb\nfrom\n'aws-cdk-lib/aws-dynamodb'\n;\nimport\n*\nas\ncdk\nfrom\n'aws-cdk-lib'\n;\nimport\n*\nas\ncr\nfrom\n'aws-cdk-lib/custom-resources'\n;\nimport\n*\nas\niam\nfrom\n'aws-cdk-lib/aws-iam'\n;\n// In your stack definition\nconst\ntableName\n=\n'YourTableName'\n;\n// Custom resource to check if the table exists\nconst\ncheckTableExists\n=\nnew\ncr\n.\nAwsCustomResource\n(\nthis\n,\n'CheckTableExists'\n,\n{\nonUpdate\n:\n{\nservice\n:\n'DynamoDB'\n,\naction\n:\n'describeTable'\n,\nparameters\n:\n{\nTableName\n:\ntableName\n,\n}\n,\nphysicalResourceId\n:\ncr\n.\nPhysicalResourceId\n.\nof\n(\nDate\n.\nnow\n(\n)\n.\ntoString\n(\n)\n)\n,\n}\n,\npolicy\n:\ncr\n.\nAwsCustomResourcePolicy\n.\nfromStatements\n(\n[\nnew\niam\n.\nPolicyStatement\n(\n{\nactions\n:\n[\n'dynamodb:DescribeTable'\n]\n,\nresources\n:\n[\n'*'\n]\n,\n}\n)\n,\n]\n)\n,\n}\n)\n;\n// Catch and handle the error if the table doesn't exist\nconst\ntableExists\n=\ncheckTableExists\n.\ngetResponseField\n(\n'Table.TableName'\n)\n;\n// Conditionally create the table\nconst\ntable\n=\ntableExists\n?\ndynamodb\n.\nTable\n.\nfromTableName\n(\nthis\n,\n'ExistingTable'\n,\ntableName\n)\n:\nnew\ndynamodb\n.\nTable\n(\nthis\n,\n'NewTable'\n,\n{\ntableName\n:\ntableName\n,\npartitionKey\n:\n{\nname\n:\n'id'\n,\ntype\n:\ndynamodb\n.\nAttributeType\n.\nSTRING\n}\n,\nremovalPolicy\n:\ncdk\n.\nRemovalPolicy\n.\nRETAIN\n,\n// ... other table properties\n}\n)\n;\n// Now you can use 'table' in the rest of your stack\nThis solution uses a custom resource to call the DynamoDB\ndescribeTable\nAPI. If the table exists, it will return the table details. If it doesn't exist, it will throw an error, which is caught and handled.\nBased on whether the table exists or not, we either reference the existing table using\nfromTableName\nor create a new one.\nRemember to handle any errors that might occur during this process and ensure your IAM permissions are set up correctly to allow describing and creating DynamoDB tables.\nSources\nCDK TypeScript: Conditional Creation of DynamoDB Table | AWS re:Post\nBoto3, Is there a straightforward convention on checking that a DynamoDB table exists? | AWS re:Post\n\nas suggested above, Custom resource to check if the table exists but what if table doesn't exists?\nit will thrown an 'ResourceNotFoundException' error ?\nis 'getResponseField' is compatible with 'ResourceNotFoundException' error ?\n\nWhen the table doesn't exist, the\ngetResponseField\nwill throw an error because there's no response to get fields from. Here's a better implementation:\nimport\n*\nas\ncdk\nfrom\n'aws-cdk-lib'\n;\nimport\n*\nas\ndynamodb\nfrom\n'aws-cdk-lib/aws-dynamodb'\n;\nimport\n*\nas\ncr\nfrom\n'aws-cdk-lib/custom-resources'\n;\nexport\nclass\nMyStack\nextends\ncdk\n.\nStack\n{\nconstructor\n(\nscope\n:\nConstruct\n,\nid\n:\nstring\n,\nprops\n?\n:\ncdk\n.\nStackProps\n)\n{\nsuper\n(\nscope\n,\nid\n,\nprops\n)\n;\nconst\ntableName\n=\n'YourTableName'\n;\n// Create a Custom Resource to check if the table exists\nconst\ntableExistenceCheck\n=\nnew\ncr\n.\nAwsCustomResource\n(\nthis\n,\n'CheckTableExistence'\n,\n{\nonCreate\n:\n{\nservice\n:\n'DynamoDB'\n,\naction\n:\n'describeTable'\n,\nparameters\n:\n{\nTableName\n:\ntableName\n}\n,\nphysicalResourceId\n:\ncr\n.\nPhysicalResourceId\n.\nof\n(\ntableName\n)\n,\nignoreErrorCodesMatching\n:\n'ResourceNotFoundException'\n,\n// This is key\n}\n,\npolicy\n:\ncr\n.\nAwsCustomResourcePolicy\n.\nfromSdkCalls\n(\n{\nresources\n:\ncr\n.\nAwsCustomResourcePolicy\n.\nANY_RESOURCE\n,\n}\n)\n,\n}\n)\n;\n// Add explicit dependency to ensure the check happens first\nconst\ntableExists\n=\ntableExistenceCheck\n.\ngetResponseField\n(\n'Table'\n)\n!==\nundefined\n;\nlet\ntable\n:\ndynamodb\n.\nITable\n;\nif\n(\ntableExists\n)\n{\nconsole\n.\nlog\n(\n`\nTable\n${\ntableName\n}\nexists, creating reference\n`\n)\n;\ntable\n=\ndynamodb\n.\nTable\n.\nfromTableName\n(\nthis\n,\n'ExistingTable'\n,\ntableName\n)\n;\n}\nelse\n{\nconsole\n.\nlog\n(\n`\nTable\n${\ntableName\n}\ndoes not exist, creating new table\n`\n)\n;\ntable\n=\nnew\ndynamodb\n.\nTableV2\n(\nthis\n,\n'NewTable'\n,\n{\ntableName\n:\ntableName\n,\npartitionKey\n:\n{\nname\n:\n'id'\n,\ntype\n:\ndynamodb\n.\nAttributeType\n.\nSTRING\n}\n,\nremovalPolicy\n:\ncdk\n.\nRemovalPolicy\n.\nRETAIN\n,\n}\n)\n;\n}\n}\n}\nKey changes and explanations:\nChanged\ncatchErrorPattern\nto\nignoreErrorCodesMatching\n:\nignoreErrorCodesMatching\n:\n'ResourceNotFoundException'\nThis tells the custom resource to not fail when the table doesn't exist.\nChanged the existence check:\nconst\ntableExists\n=\ntableExistenceCheck\n.\ngetResponseField\n(\n'Table'\n)\n!==\nundefined\n;\nWhen the table doesn't exist, the response will be undefined, making this check safe.\nYou can also add error handling using a try-catch block:\nlet\ntableExists\n=\nfalse\n;\ntry\n{\ntableExists\n=\ntableExistenceCheck\n.\ngetResponseField\n(\n'Table'\n)\n!==\nundefined\n;\n}\ncatch\n(\nerror\n)\n{\nconsole\n.\nlog\n(\n'Error checking table existence:'\n,\nerror\n)\n;\ntableExists\n=\nfalse\n;\n}"
}