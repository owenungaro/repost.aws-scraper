{
  "body": "Hello. I have implemented a Lambda @ Edge function very similar to the one outlined here\nhttps://aws.amazon.com/blogs/networking-and-content-delivery/dynamically-route-viewer-requests-to-any-origin-using-lambdaedge/\nin order to serve content from two different S3 buckets for different portions of traffic.\nThe function seems to be executing ok - I have added various log statements that I can see in the Cloudwatch logs.\nHere is the code:\nexport const handler = async (event, context, callback) => {\n  const request = event.Records[0].cf.request;\n  const headers = request.headers;\n  const origin = request.origin;\n\n  //Setup the two different origins\n  const originA = \"bucketA.s3.eu-west-2.amazonaws.com\";\n  const originB = \"bucketB.s3.eu-west-2.amazonaws.com\";\n\n  console.log(`Current origin is \\n${JSON.stringify(origin)}`);\n\n  if(!origin.s3) {\n    console.log('Origin not S3, returning');\n    callback(null, request);\n    return;\n    }\n\n  if (headers.cookie) {\n    for (let i = 0; i < headers.cookie.length; i++) {\n        if (headers.cookie[i].value.indexOf('origin=A') >= 0) {\n            console.log('Origin A cookie found');\n            headers['host'] = [{key: 'host',          value: originA}];\n            origin.s3.domainName = originA;\n            // origin.s3.path = \"index.html\";\n            break;\n        } else if (headers.cookie[i].value.indexOf('origin=B') >= 0) {\n            console.log('Origin B cookie found');\n            headers['host'] = [{key: 'host',          value: originB}];\n            origin.s3.domainName = originB;\n            // origin.s3.path = \"index.html\";\n            break;\n        }\n    }\n  } \n  else\n  {\n      //New visitor so no cookie set, roll the dice weight to origin A\n      //Could also just choose to return here rather than modifying the request\n      if (Math.random() < 0.75) {\n          headers['host'] = [{key: 'host',          value: originA}];\n          origin.s3.domainName = originA;\n          console.log('Rolled the dice and origin A it is!');\n      } else {\n          headers['host'] = [{key: 'host',          value: originB}];\n          origin.s3.domainName = originB;\n          console.log('Rolled the dice and origin B it is!');\n      }\n  }\n\n  console.log(`New origin is \\n${JSON.stringify(origin)}`);\n  request.origin = origin;\n  request.headers = headers;\n\n  callback(null, request);\n\n};\nI can see results in the logs like this:\n2025-05-28T13:16:41.456Z\n2025-05-28T13:16:41.456Z f161090f-1e81-4140-8583-173d44d14f24 INFO Current origin is {\"s3\":{\"authMethod\":\"none\",\"customHeaders\":{},\"domainName\":\"bucketA.eu-west-2.amazonaws.com\",\"path\":\"\"}}\n2025-05-28T13:16:41.457Z\n2025-05-28T13:16:41.457Z f161090f-1e81-4140-8583-173d44d14f24 INFO Rolled the dice and origin A it is!\n2025-05-28T13:16:41.457Z\n2025-05-28T13:16:41.457Z f161090f-1e81-4140-8583-173d44d14f24 INFO New origin is {\"s3\":{\"authMethod\":\"none\",\"customHeaders\":{},\"domainName\":\"bucketA.s3.eu-west-2.amazonaws.com\",\"path\":\"\"}}\n...\n2025-05-28T13:17:37.084Z\n2025-05-28T13:17:37.084Z df45ff51-7c35-4488-bdde-6fb58890d855 INFO Current origin is {\"s3\":{\"authMethod\":\"none\",\"customHeaders\":{},\"domainName\":\"bucketA.s3.eu-west-2.amazonaws.com\",\"path\":\"\"}}\n2025-05-28T13:17:37.084Z\n2025-05-28T13:17:37.084Z df45ff51-7c35-4488-bdde-6fb58890d855 INFO Rolled the dice and origin B it is!\n2025-05-28T13:17:37.084Z\n2025-05-28T13:17:37.084Z df45ff51-7c35-4488-bdde-6fb58890d855 INFO New origin is {\"s3\":{\"authMethod\":\"none\",\"customHeaders\":{},\"domainName\":\"bucketB.s3.eu-west-2.amazonaws.com\",\"path\":\"\"}}\nHowever, the content returned is always that from Bucket A.\nI have set the default TTL in the CloudFront distribution to 0 in order to avoid caching.\nThe buckets have slightly different permissions - Bucket A is only accessible to the Cloudfront distribution whereas Bucket B is publicly accessible.\nThe function trigger is set to Origin-Request.\nSince I am not seeing any\nerrors\nin the logs I am not able to debug the problem - it just doesn't work. I notice a lot of people have issues with not seeing the logs - that is not my problem. I can see the logs in the region closest to the CF distribution (eu-west-2) and the logs include my logging. It's just the content served is not varying.\nAny ideas?\n\nI think this is a caching problem. Using curl I was seeing that every request was a cloudfront x-cache hit, so I changed the behaviour of the distribution to a cache policy with compression for S3 support and a minimum and default TTL both set to 0. I also changed my code so that the split was not 75/25 but 50/50. The behaviour seems to work now - I am seeing different content served from both buckets when making new requests  with cookies cleared.\n\nHello,\nI replicated this set up with caching enabled for my distribution and it worked as expected. Requests with cookie \"origin=A\" got routed to Bucket A and requests with cookie \"origin=B\" got routed to Bucket B.\nI understand that you suspect this to be a caching problem as setting both minimum and default TTL to 0 solved the issue. I am suspecting that you are not including the \"origin\" cookie as part of the cache key[1], due to which CloudFront treats both the requests with cookie \"origin=A\" and \"origin=B\" to have the same cache key, and hence serves the same response for both the requests.\nThe logs that you have shared shows \"Rolled the dice...\" indicating that the Lambda@Edge function is not choosing the origin based on the cookie (because it doesn't seem to be present), but rather choosing it randomly based on the logic in the else block. This leads me to believe that you might not be forwarding the cookie to the Lambda@Edge function :\n...\n...\n else\n  {\n      //New visitor so no cookie set, roll the dice weight to origin A\n      //Could also just choose to return here rather than modifying the request\n      if (Math.random() < 0.75) {\n...\n...\nPlease make sure that you include the \"origin\" cookie in your cache policy[2], or incase you are using legacy cache settings, make sure to perform the following steps :\nOpen your distribution and click on \"Behaviors\" tab.\nSelect the respective behavior and click on \"Edit\".\nUnder Legacy cache settings, you will find \"Cookies\". Under the dropdown, select \"Include the following cookies\".\nUnder \"Add cookie\", please specify \"origin\"\nClick on \"Save changes\".\nOnce you have performed these changes, make sure to perform an invalidation[3] so that you can remove the previously cached content from CloudFront's edge locations.\nReferences :\n[1] Cache key :\nhttps://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/understanding-the-cache-key.html\n[2] Cache policy :\nhttps://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cache-key-understand-cache-policy.html\n[3] Invalidation :\nhttps://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html"
}